-- Products table
-- Table: public.products

-- DROP TABLE IF EXISTS public.products;

CREATE TABLE IF NOT EXISTS public.products
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    product character varying COLLATE pg_catalog."default" NOT NULL,
    price double precision,
    "productDescription" character varying COLLATE pg_catalog."default",
    "productName" character varying COLLATE pg_catalog."default" NOT NULL,
    colors text[] COLLATE pg_catalog."default",
    "imageUrl" character varying COLLATE pg_catalog."default",
    "isNew" boolean DEFAULT false,
    category text COLLATE pg_catalog."default",
    discount numeric,
    rating real,
    reviews integer,
    CONSTRAINT products_pkey PRIMARY KEY (id),
    CONSTRAINT products_id_key UNIQUE (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.products
    OWNER to postgres;

ALTER TABLE IF EXISTS public.products
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.products TO anon;

GRANT ALL ON TABLE public.products TO authenticated;

GRANT ALL ON TABLE public.products TO postgres;

GRANT ALL ON TABLE public.products TO service_role;
-- POLICY: Enable read access for all users

-- DROP POLICY IF EXISTS "Enable read access for all users" ON public.products;

CREATE POLICY "Enable read access for all users"
    ON public.products
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (true);

-----------------------------------------

-- Wishlist table
-- Table: public.wishlist

-- DROP TABLE IF EXISTS public.wishlist;

CREATE TABLE IF NOT EXISTS public.wishlist
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    product_id bigint,
    user_id uuid,
    CONSTRAINT wishlist_pkey PRIMARY KEY (id),
    CONSTRAINT wishlist_id_key UNIQUE (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.wishlist
    OWNER to postgres;

ALTER TABLE IF EXISTS public.wishlist
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.wishlist TO anon;

GRANT ALL ON TABLE public.wishlist TO authenticated;

GRANT ALL ON TABLE public.wishlist TO postgres;

GRANT ALL ON TABLE public.wishlist TO service_role;
-- POLICY: access to user wish list

-- DROP POLICY IF EXISTS "access to user wish list" ON public.wishlist;

CREATE POLICY "access to user wish list"
    ON public.wishlist
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((user_id = auth.uid()));
-- POLICY: deleting a wish list item

-- DROP POLICY IF EXISTS "deleting a wish list item" ON public.wishlist;

CREATE POLICY "deleting a wish list item"
    ON public.wishlist
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((user_id = auth.uid()));
-- POLICY: insert policy for wish list

-- DROP POLICY IF EXISTS "insert policy for wish list" ON public.wishlist;

CREATE POLICY "insert policy for wish list"
    ON public.wishlist
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((user_id = auth.uid()));

------------------------------------------

-- Cart table
-- Table: public.cart

-- DROP TABLE IF EXISTS public.cart;

CREATE TABLE IF NOT EXISTS public.cart
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    product_id bigint,
    user_id uuid,
    quantity bigint NOT NULL DEFAULT '1'::bigint,
    CONSTRAINT cart_pkey PRIMARY KEY (id),
    CONSTRAINT cart_id_key UNIQUE (id),
    CONSTRAINT cart_quantity_check CHECK (quantity > 0)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.cart
    OWNER to postgres;

ALTER TABLE IF EXISTS public.cart
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.cart TO anon;

GRANT ALL ON TABLE public.cart TO authenticated;

GRANT ALL ON TABLE public.cart TO postgres;

GRANT ALL ON TABLE public.cart TO service_role;

COMMENT ON COLUMN public.cart.quantity
    IS 'Product quantity';
-- POLICY: Enable delete for users based on user_id

-- DROP POLICY IF EXISTS "Enable delete for users based on user_id" ON public.cart;

CREATE POLICY "Enable delete for users based on user_id"
    ON public.cart
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING ((( SELECT auth.uid() AS uid) = user_id));
-- POLICY: Enable insert for users based on user_id

-- DROP POLICY IF EXISTS "Enable insert for users based on user_id" ON public.cart;

CREATE POLICY "Enable insert for users based on user_id"
    ON public.cart
    AS PERMISSIVE
    FOR INSERT
    TO public
    WITH CHECK ((( SELECT auth.uid() AS uid) = user_id));
-- POLICY: Enable read access for based on user_id

-- DROP POLICY IF EXISTS "Enable read access for based on user_id" ON public.cart;

CREATE POLICY "Enable read access for based on user_id"
    ON public.cart
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((user_id = auth.uid()));
-- POLICY: Users can update their own cart entries

-- DROP POLICY IF EXISTS "Users can update their own cart entries" ON public.cart;

CREATE POLICY "Users can update their own cart entries"
    ON public.cart
    AS PERMISSIVE
    FOR UPDATE
    TO authenticated
    USING ((( SELECT auth.uid() AS uid) = user_id))
    WITH CHECK ((( SELECT auth.uid() AS uid) = user_id));


------------------------------------------

-- Table: public.profiles

-- DROP TABLE IF EXISTS public.profiles;

CREATE TABLE IF NOT EXISTS public.profiles
(
    id uuid NOT NULL,
    first_name text COLLATE pg_catalog."default",
    last_name text COLLATE pg_catalog."default",
    address text COLLATE pg_catalog."default",
    email text COLLATE pg_catalog."default",
    CONSTRAINT profiles_pkey PRIMARY KEY (id),
    CONSTRAINT profiles_email_key UNIQUE (email),
    CONSTRAINT profiles_id_fkey FOREIGN KEY (id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE CASCADE
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.profiles
    OWNER to postgres;

ALTER TABLE IF EXISTS public.profiles
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.profiles TO anon;

GRANT ALL ON TABLE public.profiles TO authenticated;

GRANT ALL ON TABLE public.profiles TO postgres;

GRANT ALL ON TABLE public.profiles TO service_role;
-- POLICY: Enable insert for authenticated users only

-- DROP POLICY IF EXISTS "Enable insert for authenticated users only" ON public.profiles;

CREATE POLICY "Enable insert for authenticated users only"
    ON public.profiles
    AS PERMISSIVE
    FOR INSERT
    TO authenticated
    WITH CHECK ((id = auth.uid()));
-- POLICY: Enable read access fo authed user

-- DROP POLICY IF EXISTS "Enable read access fo authed user" ON public.profiles;

CREATE POLICY "Enable read access fo authed user"
    ON public.profiles
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING ((( SELECT auth.uid() AS uid) = id));
-- POLICY: Update policy

-- DROP POLICY IF EXISTS "Update policy" ON public.profiles;

CREATE POLICY "Update policy"
    ON public.profiles
    AS PERMISSIVE
    FOR UPDATE
    TO public
    USING ((( SELECT auth.uid() AS uid) = id))
    WITH CHECK ((( SELECT auth.uid() AS uid) = id));


------------------------------------------

-- FUNCTIONS


-- FUNCTION: public.handle_new_user()

-- DROP FUNCTION IF EXISTS public.handle_new_user();

CREATE OR REPLACE FUNCTION public.handle_new_user()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF SECURITY DEFINER
    SET search_path=""
AS $BODY$
begin
  insert into public.profiles (id, first_name, last_name, address, email)
  values (new.id, new.raw_user_meta_data ->> 'first_name', new.raw_user_meta_data ->> 'last_name', '', new.email);
  return new;
end;
$BODY$;

ALTER FUNCTION public.handle_new_user()
    OWNER TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO PUBLIC;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO anon;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO authenticated;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO postgres;

GRANT EXECUTE ON FUNCTION public.handle_new_user() TO service_role;

